/* Please do not edit this file - it has been automatically generated by jFaSM */

package marketpricing;

import java.util.Calendar;

import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

final class MarketStateImpl implements MarketState {

	private final ReadWriteLock lock = new ReentrantReadWriteLock();
	private final marketpricing.MarketHashKey key;

	private final marketpricing.MarketPricingEngine marketPricingEngine;

	private final MarketState_OPEN marketState_OPEN = new MarketState_OPEN();

	private final MarketState_EXPIRED marketState_EXPIRED = new MarketState_EXPIRED();

	private final MarketState_AFTER_LAST_TRADE marketState_AFTER_LAST_TRADE = new MarketState_AFTER_LAST_TRADE();

	private final MarketState_CLOSED_FOR_FEED_FAILURE marketState_CLOSED_FOR_FEED_FAILURE = new MarketState_CLOSED_FOR_FEED_FAILURE();

	private marketpricing.Price price;
	private java.lang.String marketName;
	private java.util.Date priceLastReceived;
	private MarketState marketStateInternal = marketState_OPEN;

	public MarketStateImpl(
			final marketpricing.MarketHashKey key,
			final marketpricing.MarketPricingEngine marketPricingEngine) {

		this.key = key;
		this.marketPricingEngine = marketPricingEngine;
	}

	public State getState() {
		return marketStateInternal.getState();
	}

	public marketpricing.Price getPrice() {
		return price;
	}

	public java.lang.String getMarketName() {
		return marketName;
	}

	public java.util.Date getPriceLastReceived() {
		return priceLastReceived;
	}

	private abstract class AbstractMarketState implements MarketState {

		public abstract State getState();

		public void feedFailure() {
			throw new UnsupportedOperationException();
		}

		public void expiryTimePassed() {
			throw new UnsupportedOperationException();
		}

		public void priceReceived(
				final marketpricing.Price price) {
			throw new UnsupportedOperationException();
		}

		public final void lastTradeTimePassed() {
			MarketStateImpl.this.marketStateInternal = MarketStateImpl.this.marketState_AFTER_LAST_TRADE;
		}

	}

	private final class MarketState_OPEN extends AbstractMarketState {

		public State getState() {
			return State.OPEN;
		}

		@Override
		public void feedFailure() {
			lock.writeLock().lock();
			try {
				MarketStateImpl.this.marketStateInternal = MarketStateImpl.this.marketState_CLOSED_FOR_FEED_FAILURE;
			} finally {
				lock.writeLock().unlock();
			}
		}

		@Override
		public void priceReceived(
				final marketpricing.Price price) {
			MarketStateImpl.this.price = price;
			marketPricingEngine.sendPrice(key);
			MarketStateImpl.this.priceLastReceived = Calendar.getInstance()
					.getTime();
		}
	}

	private final class MarketState_EXPIRED extends AbstractMarketState {

		public State getState() {
			return State.EXPIRED;
		}

	}

	private final class MarketState_AFTER_LAST_TRADE extends
			AbstractMarketState {

		public State getState() {
			return State.AFTER_LAST_TRADE;
		}

		@Override
		public void expiryTimePassed() {
			lock.writeLock().lock();
			try {
				MarketStateImpl.this.marketStateInternal = MarketStateImpl.this.marketState_EXPIRED;
			} finally {
				lock.writeLock().unlock();
			}
		}
	}

	private final class MarketState_CLOSED_FOR_FEED_FAILURE extends
			AbstractMarketState {

		public State getState() {
			return State.CLOSED_FOR_FEED_FAILURE;
		}

		@Override
		public void priceReceived(
				final marketpricing.Price price) {
			MarketStateImpl.this.price = price;
			lock.writeLock().lock();
			try {
				MarketStateImpl.this.marketStateInternal = MarketStateImpl.this.marketState_OPEN;
			} finally {
				lock.writeLock().unlock();
			}
		}
	}

}
