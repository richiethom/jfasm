package jfasm.generator;

import java.text.MessageFormat;
import java.util.Map;
import java.util.Set;
import java.util.Map.Entry;

public class ClassGenerator extends AbstractGenerator {
	
	private final boolean needsCalendar;
	private final boolean threadSafe;
	private final String associatedWith;
	private Map<String, EventListenerConfiguration> eventListeners;
	private Map<String, Property> fields;
	private String startState;

	protected ClassGenerator(String name, Map<String, State> states, Map<String, EventConfiguration> events, boolean needsCalendar, boolean threadSafe, String associatedWith, Map<String, EventListenerConfiguration> eventListeners2, Map<String, Property> fields, String startState, String packageName) {
		super(name, states, events, packageName);
		this.needsCalendar = needsCalendar;
		this.threadSafe = threadSafe;
		this.associatedWith = associatedWith;
		this.eventListeners = eventListeners2;
		this.fields = fields;
		this.startState = startState;
	}
	
	private void outputComment(StringBuilder stringBuilder, String string) {
		stringBuilder.append(MessageFormat.format("/* {0} */\n\n", string));
	}
	
	private void generateGap(final StringBuilder stringBuilder) {
		stringBuilder.append("\n\n");
	}
	
	private void generateClassDeclaration(final StringBuilder stringBuilder) {
		stringBuilder.append(MessageFormat.format("final class {0}Impl implements {0} ", name));
		stringBuilder.append("{\n\n");
	}
	
	private String generateVariableName(String valueToChange) {
		return valueToChange.substring(0, 1).toLowerCase()+valueToChange.substring(1);
	}
	
	private String generateUpperCaseName(String valueToChange) {
		return valueToChange.substring(0, 1).toUpperCase()+valueToChange.substring(1);
	}
	
	private void generateGetter(StringBuilder stringBuilder, Map.Entry<String, Property> field) {
		stringBuilder.append(MessageFormat.format("public {0} get{1}()", field.getValue().getClazz().getName(), generateUpperCaseName(field.getKey())));
		stringBuilder.append("{\n");
		stringBuilder.append("return ");
		stringBuilder.append(field.getKey());
		stringBuilder.append(";\n}\n\n");
	}

	private void outputFields(StringBuilder stringBuilder) {
		final Set<Entry<String, Property>> entrySet = fields.entrySet();
		for (Entry<String, Property> entry : entrySet) {
			stringBuilder.append(MessageFormat.format("private {0} {1};\n", entry.getValue().getClazz().getName(), entry.getKey()));
		}
	}

	@Override
	protected void generate() {
		final StringBuilder stringBuilder = new StringBuilder();
		outputComment(stringBuilder, "Please do not edit this file - it has been automatically generated by jFaSM");
		generatePackage(stringBuilder);
		if (needsCalendar) {
			stringBuilder.append("import java.util.Calendar;\n\n");
		}
		if (threadSafe) {
			stringBuilder.append("import java.util.concurrent.locks.ReadWriteLock;\n");
			stringBuilder.append("import java.util.concurrent.locks.ReentrantReadWriteLock;\n");
		}
		generateGap(stringBuilder);
		generateClassDeclaration(stringBuilder);
		
		if (threadSafe) {
			stringBuilder.append("private final ReadWriteLock lock = new ReentrantReadWriteLock();\n");
		}
		
		stringBuilder.append(MessageFormat.format("private final {0} key;", associatedWith));
		generateGap(stringBuilder);
		for (Entry<String, EventListenerConfiguration> entry : eventListeners.entrySet()) {
			stringBuilder.append(MessageFormat.format("private final {1} {0};", entry.getKey(), entry.getValue().getGeneratedInterface()));
			generateGap(stringBuilder);
		}
		
		final String nameWithLowerCaseFirstLetter = generateVariableName(name);
		
		for (Entry<String, State> entry : states.entrySet()) {
			stringBuilder.append(MessageFormat.format("private final {0}_{1} {2}_{1} = new {0}_{1}();",name, entry.getKey(), nameWithLowerCaseFirstLetter));
			generateGap(stringBuilder);
		}

		outputFields(stringBuilder);
		
		stringBuilder.append(MessageFormat.format("private {0} {1}Internal = {1}_{2};", name, nameWithLowerCaseFirstLetter, startState));
		generateGap(stringBuilder);
		
		stringBuilder.append(MessageFormat.format("public {0}Impl(final {1} key", name, associatedWith));
		final int eventListenersCount = eventListeners.size();
		final StringBuilder instantiationStringBuilder = new StringBuilder();
		if (eventListenersCount>0) {
			stringBuilder.append(", ");
			int currentEventListener = 0;
			for (Entry<String, EventListenerConfiguration> entry : eventListeners.entrySet()) {
				++currentEventListener;
				stringBuilder.append(MessageFormat.format("final {1} {0}", entry.getKey(), entry.getValue().getGeneratedInterface()));
				instantiationStringBuilder.append(MessageFormat.format("this.{0} = {0}", entry.getKey()));
				instantiationStringBuilder.append(";\n");
				if (currentEventListener<eventListenersCount) {
					stringBuilder.append(",");
				}
			}
		}
		stringBuilder.append(") {\n\n");
		stringBuilder.append("this.key = key;\n");
		stringBuilder.append(instantiationStringBuilder);
		stringBuilder.append("}");
		generateGap(stringBuilder);
		
		stringBuilder.append("public State getState() {\nreturn "+ nameWithLowerCaseFirstLetter +"Internal.getState();\n}\n\n");
		for (Map.Entry<String, Property> field : fields.entrySet()) {
			generateGetter(stringBuilder, field);
		}

		stringBuilder.append(MessageFormat.format("private abstract class Abstract{0} implements {0}", name));
		stringBuilder.append("{\n\n");
		stringBuilder.append("public abstract State getState();\n\n");
		for (Entry<String, EventConfiguration> entry : events.entrySet()) {
			final String globalTransitionFinal;
			if (entry.getValue().hasGlobalTransition()) {
				globalTransitionFinal = "final";
			} else {
				globalTransitionFinal = "";
			}
			stringBuilder.append(MessageFormat.format("public {1} void {0}(", entry.getKey(), globalTransitionFinal));
			if (entry.getValue().hasParameters()) {
				final Map<String, String> parameters = entry.getValue().getParameters();
				final int parametersSize = parameters.size();
				int currentParameter = 0;
				for (final Entry<String, String> entrySet : parameters.entrySet()) {
					++currentParameter;
					stringBuilder.append(MessageFormat.format("final {0} {1}", entrySet.getValue(), entrySet.getKey()));
					if (currentParameter < parametersSize) {
						stringBuilder.append(", ");
					}
				}
			}
			stringBuilder.append(") {\n");
			if (entry.getValue().hasGlobalTransition()) {
				stringBuilder.append(MessageFormat.format("{0}Impl.this.{1}Internal = {0}Impl.this.{1}_{2};\n", name, nameWithLowerCaseFirstLetter, entry.getValue().getGlobalTransition()));
			} else {
				stringBuilder.append("throw new UnsupportedOperationException();\n");
			}
			stringBuilder.append("}\n\n");
		}
		
		
		stringBuilder.append("}");
		
		for (Entry<String, State> entry : states.entrySet()) {
			stringBuilder.append(MessageFormat.format("private final class {0}_{1} extends Abstract{0}",name, entry.getKey()));
			stringBuilder.append("{\n\n");
			
			stringBuilder.append("public State getState() {\n");
			stringBuilder.append(MessageFormat.format("return State.{0};\n", entry.getKey()));
			stringBuilder.append("}\n\n");
			
			final State value = entry.getValue();
			for (final OnEvent onEventTransition : value.getOnEventTransitions()) {
				stringBuilder.append("@Override\n");
				final EventConfiguration eventConfiguration = events.get(onEventTransition.getName());
				final String parameterString;
				if (!eventConfiguration.hasParameters()) {
					parameterString = "";
				} else {
					final StringBuilder parametersStringBuilder = new StringBuilder();
					final int parameterCount = eventConfiguration.getParameters().size();
					int currentParameter = 0;
					for (Map.Entry<String, String> parameterEntry : eventConfiguration.getParameters().entrySet()) {
						++currentParameter;
						parametersStringBuilder.append("final ");
						parametersStringBuilder.append(parameterEntry.getValue());
						parametersStringBuilder.append(" ");
						parametersStringBuilder.append(parameterEntry.getKey());
						if (currentParameter < parameterCount) {
							parametersStringBuilder.append(", ");
						}
					}
					parameterString = parametersStringBuilder.toString();
				}
				stringBuilder.append(MessageFormat.format("public void {0}({1})", onEventTransition.getName(), parameterString));
				stringBuilder.append("{\n");
				if (parameterString.length()>0) {
					//assign the parameters!!!
					final int parameterCount = eventConfiguration.getParameters().size();
					int currentParameter = 0;
					for (Map.Entry<String, String> parameterEntry : eventConfiguration.getParameters().entrySet()) {
						++currentParameter;
						stringBuilder.append(MessageFormat.format("{1}Impl.this.{0} = {0};\n", parameterEntry.getKey(), name));
					}
				}
				final String event = onEventTransition.getEvent();
				if (event!=null) {
					final Parameter parameter = onEventTransition.getParameter();
					final String innerParameterString;
					if (parameter!=null) {
						switch (parameter) {
						case KEY:
							innerParameterString = "key";
							break;
						case STATE:
							innerParameterString = "getState()";
							break;
						case THIS:
							innerParameterString = "this";
							break;
						default:
							innerParameterString = "";
							break;
						}
					} else {
						innerParameterString = "";
					}
					stringBuilder.append(MessageFormat.format("{0}({1});\n", event, innerParameterString));
				}
				if (onEventTransition.getTimeStamp()!=null && onEventTransition.getTimeStamp().length()>0) {
					stringBuilder.append(MessageFormat.format("{1}Impl.this.{0} = Calendar.getInstance().getTime();\n", onEventTransition.getTimeStamp(), name));
				}
				final String transitionTo = onEventTransition.getTransitionTo();
				System.out.println("-->> "+transitionTo+", "+entry.getKey());
				if (!transitionTo.equals(entry.getKey())) {
					if (threadSafe) {
						stringBuilder.append("lock.writeLock().lock();\n");
						stringBuilder.append("try {\n");
					}
					stringBuilder.append(MessageFormat.format("{0}Impl.this.{1}Internal = {0}Impl.this.{1}_{2};\n", name, nameWithLowerCaseFirstLetter, transitionTo));
					if (threadSafe) {
						stringBuilder.append("} finally {\n");
						stringBuilder.append("lock.writeLock().unlock();\n");
						stringBuilder.append("}");
					}
				}
				
				stringBuilder.append("}\n");
				
			}
			
			stringBuilder.append("}");
			generateGap(stringBuilder);
		}
		
		stringBuilder.append("}");
		
		System.out.println(stringBuilder.toString());		
	}

}
